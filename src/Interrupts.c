//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================


// USER INCLUDES
#include <SI_EFM8SB1_Register_Enums.h>

#include "InitDevice.h"

volatile int count_timer;
volatile unsigned int count;
//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
/*
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{
	TMR2CN0_TF2H = 0;             // clear Timer2 interrupt flag
//	LED0 = !LED0;                 // change state of LED
}*/

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
void timer_sleepus_select(int para,int t)//0xFFFE-1us 0xFFEC-10us 0xFFCD-25us 0xFF9A-50us 0xFF67-75us 0xFF34-100us 0xFE68-200us 0xFE02-250us 68us-ff75 71us-ff6f
{																//FFAE-40us
	uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
	uint8_t TMER2H_value;
	uint8_t TMER2L_value;
	switch(para){
	case 1:
			TMER2H_value=0xFF;
			TMER2L_value=0xFE;
			break;
	case 10:
		TMER2H_value=0xFF;
		TMER2L_value=0xEC;
		break;
	case 25:
		TMER2H_value=0xFF;
		TMER2L_value=0xCD;
		break;
	case 40:
		TMER2H_value=0xFF;
		TMER2L_value=0xAE;
		break;
	case 50:
		TMER2H_value=0xFF;
		TMER2L_value=0x9A;
		break;
	case 60:
		TMER2H_value=0xFF;
		TMER2L_value=0x86;
		break;
	case 65:
		TMER2H_value=0xFF;
		TMER2L_value=0x7C;
		break;
	case 68:
		TMER2H_value=0xFF;
		TMER2L_value=0x75;
		break;
	case 71:
		TMER2H_value=0xFF;
		TMER2L_value=0x6F;
		break;
	case 75:
		TMER2H_value=0xFF;
		TMER2L_value=0x67;
		break;
	case 90:
		TMER2H_value=0xFF;
		TMER2L_value=0x48;
		break;
	case 100:
		TMER2H_value=0xFF;
		TMER2L_value=0x34;
		break;
	case 200:
		TMER2H_value=0xFE;
		TMER2L_value=0x68;
		break;
	case 250:
		TMER2H_value=0xFE;
		TMER2L_value=0x02;
		break;
	default:
		uart_send("error para for timer_sleepus_select", sizeof("error para for timer_sleepus_select"));
	}
	//timer2 input clock :2.5x1024x1024/12
	TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
	TMR2H = (TMER2H_value << TMR2H_TMR2H__SHIFT);//TMR2H = (0xD7 << TMR2H_TMR2H__SHIFT);
	TMR2L = (TMER2L_value << TMR2L_TMR2L__SHIFT);//TMR2L = (0x60 << TMR2L_TMR2L__SHIFT);
	//set timer time TMR2RLH TMR2RLL
	TMR2RLH = (TMER2H_value << TMR2RLH_TMR2RLH__SHIFT);//TMR2RLH = (0xD7 << TMR2RLH_TMR2RLH__SHIFT);
	TMR2RLL = (TMER2L_value << TMR2RLL_TMR2RLL__SHIFT);//TMR2RLL = (0x4F << TMR2RLL_TMR2RLL__SHIFT);
	TMR2CN0 |= TMR2CN0_TR2__RUN;// TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
	TMR2CN0 |= TMR2CN0_TR2_save;// Restore Timer Configuration
	TMR2CN0 &= 0xFC; //T2XCLK: External Clock is SYSCLK/12.
	count_timer=0;
	while(1){
		if(count_timer>=t){
			count_timer=0;
			break;
		}
	}
	TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
}
void set_timer2(uint8_t us)
{
	uint8_t TMER2H_value;
	uint8_t TMER2L_value;
	uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
	switch(us){
		case 10:
			TMER2H_value=0xFF;
			TMER2L_value=0xEC;
			break;
		case 25:
			TMER2H_value=0xFF;
			TMER2L_value=0xCD;
			break;
		case 50:
			TMER2H_value=0xFF;
			TMER2L_value=0x9A;
			break;
		case 75:
			TMER2H_value=0xFF;
			TMER2L_value=0x67;
			break;
		case 100:
			TMER2H_value=0xFF;
			TMER2L_value=0x34;
			break;
		case 200:
			TMER2H_value=0xFE;
			TMER2L_value=0x68;
			break;
		case 250:
			TMER2H_value=0xFE;
			TMER2L_value=0x02;
			break;
		default:
			uart_send("error para for set_timer", sizeof("error para for set_timer"));
	}

	TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
	TMR2H = (TMER2H_value << TMR2H_TMR2H__SHIFT);//TMR2H = (0xD7 << TMR2H_TMR2H__SHIFT);
	TMR2L = (TMER2L_value << TMR2L_TMR2L__SHIFT);//TMR2L = (0x60 << TMR2L_TMR2L__SHIFT);
	//set timer time TMR2RLH TMR2RLL
	TMR2RLH = (TMER2H_value << TMR2RLH_TMR2RLH__SHIFT);//TMR2RLH = (0xD7 << TMR2RLH_TMR2RLH__SHIFT);
	TMR2RLL = (TMER2L_value << TMR2RLL_TMR2RLL__SHIFT);//TMR2RLL = (0x4F << TMR2RLL_TMR2RLL__SHIFT);
	TMR2CN0 |= TMR2CN0_TR2__RUN;// TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
	TMR2CN0 |= TMR2CN0_TR2_save;// Restore Timer Configuration
	TMR2CN0 &= 0xFC; //T2XCLK: External Clock is SYSCLK/12.
}

void stop_timer2()
{
	uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
	TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
}
//unsigned int mV = 0;
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{
   uint32_t result = 0;
   // mV = 0;                   // measured voltage in mV

   ADC0CN0_ADINT = 0;                  // clear ADC0 conv. complete flag

   result = ADC0;                      // copy ADC0 into result

   // The 12-bit ADC value represents the voltage applied
   // to P1.4 according to the following equation:
   //
   //                           Vref (mV)
   //   measurement (mV) =   --------------- * result (bits)
   //                       ((2^10)-1)*2^2 (bits)

  // mV =   (uint16_t)(result * 3300 / 4092);
   //mV = 0;
  // mV = (unsigned int)result;


   //clear_adc_busy();
}
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{
	TMR2CN0_TF2H = 0;             // clear Timer2 interrupt flag
	count++;
	//count_distence++;
	count_timer++;
}
