C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2020 14:55:04 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: d:\simplicitystdio\developer\toolchains\keil_8051\9.53\BIN\C51.exe E:\redtempturebee\src\Interrupts
                    -.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE
                    - INCDIR(E:\redtempturebee\inc;D:/simplicitystdio/developer/sdks/si8051/v3//Device/shared/si8051Base;D:/simplicitystdio/d
                    -eveloper/sdks/si8051/v3//Device/EFM8SB1;D:/simplicitystdio/developer/sdks/si8051/v3//Device/EFM8SB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          
  10          // USER INCLUDES
  11          #include <SI_EFM8SB1_Register_Enums.h>
  12          
  13          #include "InitDevice.h"
  14          
  15          volatile int count_timer;
  16          volatile unsigned int count;
  17          //-----------------------------------------------------------------------------
  18          // TIMER2_ISR
  19          //-----------------------------------------------------------------------------
  20          //
  21          // TIMER2 ISR Content goes here. Remember to clear flag bits:
  22          // TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
  23          // TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
  24          //
  25          //-----------------------------------------------------------------------------
  26          /*
  27          SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
  28          {
  29                  TMR2CN0_TF2H = 0;             // clear Timer2 interrupt flag
  30          //      LED0 = !LED0;                 // change state of LED
  31          }*/
  32          
  33          //-----------------------------------------------------------------------------
  34          // ADC0EOC_ISR
  35          //-----------------------------------------------------------------------------
  36          //
  37          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
  38          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
  39          //
  40          //-----------------------------------------------------------------------------
  41          void timer_sleepus_select(int para,int t)//0xFFFE-1us 0xFFEC-10us 0xFFCD-25us 0xFF9A-50us 0xFF67-75us 0xFF
             -34-100us 0xFE68-200us 0xFE02-250us 68us-ff75 71us-ff6f
  42          {                                                                                                                               //FFAE-40us
  43   1              uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
  44   1              uint8_t TMER2H_value;
  45   1              uint8_t TMER2L_value;
  46   1              switch(para){
  47   2              case 1:
  48   2                              TMER2H_value=0xFF;
  49   2                              TMER2L_value=0xFE;
  50   2                              break;
  51   2              case 10:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2020 14:55:04 PAGE 2   

  52   2                      TMER2H_value=0xFF;
  53   2                      TMER2L_value=0xEC;
  54   2                      break;
  55   2              case 25:
  56   2                      TMER2H_value=0xFF;
  57   2                      TMER2L_value=0xCD;
  58   2                      break;
  59   2              case 40:
  60   2                      TMER2H_value=0xFF;
  61   2                      TMER2L_value=0xAE;
  62   2                      break;
  63   2              case 50:
  64   2                      TMER2H_value=0xFF;
  65   2                      TMER2L_value=0x9A;
  66   2                      break;
  67   2              case 60:
  68   2                      TMER2H_value=0xFF;
  69   2                      TMER2L_value=0x86;
  70   2                      break;
  71   2              case 65:
  72   2                      TMER2H_value=0xFF;
  73   2                      TMER2L_value=0x7C;
  74   2                      break;
  75   2              case 68:
  76   2                      TMER2H_value=0xFF;
  77   2                      TMER2L_value=0x75;
  78   2                      break;
  79   2              case 71:
  80   2                      TMER2H_value=0xFF;
  81   2                      TMER2L_value=0x6F;
  82   2                      break;
  83   2              case 75:
  84   2                      TMER2H_value=0xFF;
  85   2                      TMER2L_value=0x67;
  86   2                      break;
  87   2              case 90:
  88   2                      TMER2H_value=0xFF;
  89   2                      TMER2L_value=0x48;
  90   2                      break;
  91   2              case 100:
  92   2                      TMER2H_value=0xFF;
  93   2                      TMER2L_value=0x34;
  94   2                      break;
  95   2              case 200:
  96   2                      TMER2H_value=0xFE;
  97   2                      TMER2L_value=0x68;
  98   2                      break;
  99   2              case 250:
 100   2                      TMER2H_value=0xFE;
 101   2                      TMER2L_value=0x02;
 102   2                      break;
 103   2              default:
 104   2                      uart_send("error para for timer_sleepus_select", sizeof("error para for timer_sleepus_select"));
 105   2              }
 106   1              //timer2 input clock :2.5x1024x1024/12
 107   1              TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
 108   1              TMR2H = (TMER2H_value << TMR2H_TMR2H__SHIFT);//TMR2H = (0xD7 << TMR2H_TMR2H__SHIFT);
 109   1              TMR2L = (TMER2L_value << TMR2L_TMR2L__SHIFT);//TMR2L = (0x60 << TMR2L_TMR2L__SHIFT);
 110   1              //set timer time TMR2RLH TMR2RLL
 111   1              TMR2RLH = (TMER2H_value << TMR2RLH_TMR2RLH__SHIFT);//TMR2RLH = (0xD7 << TMR2RLH_TMR2RLH__SHIFT);
 112   1              TMR2RLL = (TMER2L_value << TMR2RLL_TMR2RLL__SHIFT);//TMR2RLL = (0x4F << TMR2RLL_TMR2RLL__SHIFT);
 113   1              TMR2CN0 |= TMR2CN0_TR2__RUN;// TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
 114   1              TMR2CN0 |= TMR2CN0_TR2_save;// Restore Timer Configuration
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2020 14:55:04 PAGE 3   

 115   1              TMR2CN0 &= 0xFC; //T2XCLK: External Clock is SYSCLK/12.
 116   1              count_timer=0;
 117   1              while(1){
 118   2                      if(count_timer>=t){
 119   3                              count_timer=0;
 120   3                              break;
 121   3                      }
 122   2              }
 123   1              TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
 124   1      }
 125          void set_timer2(uint8_t us)
 126          {
 127   1              uint8_t TMER2H_value;
 128   1              uint8_t TMER2L_value;
 129   1              uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
 130   1              switch(us){
 131   2                      case 10:
 132   2                              TMER2H_value=0xFF;
 133   2                              TMER2L_value=0xEC;
 134   2                              break;
 135   2                      case 25:
 136   2                              TMER2H_value=0xFF;
 137   2                              TMER2L_value=0xCD;
 138   2                              break;
 139   2                      case 50:
 140   2                              TMER2H_value=0xFF;
 141   2                              TMER2L_value=0x9A;
 142   2                              break;
 143   2                      case 75:
 144   2                              TMER2H_value=0xFF;
 145   2                              TMER2L_value=0x67;
 146   2                              break;
 147   2                      case 100:
 148   2                              TMER2H_value=0xFF;
 149   2                              TMER2L_value=0x34;
 150   2                              break;
 151   2                      case 200:
 152   2                              TMER2H_value=0xFE;
 153   2                              TMER2L_value=0x68;
 154   2                              break;
 155   2                      case 250:
 156   2                              TMER2H_value=0xFE;
 157   2                              TMER2L_value=0x02;
 158   2                              break;
 159   2                      default:
 160   2                              uart_send("error para for set_timer", sizeof("error para for set_timer"));
 161   2              }
 162   1      
 163   1              TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
 164   1              TMR2H = (TMER2H_value << TMR2H_TMR2H__SHIFT);//TMR2H = (0xD7 << TMR2H_TMR2H__SHIFT);
 165   1              TMR2L = (TMER2L_value << TMR2L_TMR2L__SHIFT);//TMR2L = (0x60 << TMR2L_TMR2L__SHIFT);
 166   1              //set timer time TMR2RLH TMR2RLL
 167   1              TMR2RLH = (TMER2H_value << TMR2RLH_TMR2RLH__SHIFT);//TMR2RLH = (0xD7 << TMR2RLH_TMR2RLH__SHIFT);
 168   1              TMR2RLL = (TMER2L_value << TMR2RLL_TMR2RLL__SHIFT);//TMR2RLL = (0x4F << TMR2RLL_TMR2RLL__SHIFT);
 169   1              TMR2CN0 |= TMR2CN0_TR2__RUN;// TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
 170   1              TMR2CN0 |= TMR2CN0_TR2_save;// Restore Timer Configuration
 171   1              TMR2CN0 &= 0xFC; //T2XCLK: External Clock is SYSCLK/12.
 172   1      }
 173          
 174          void stop_timer2()
 175          {
 176   1              uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
 177   1              TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);// Stop Timer
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2020 14:55:04 PAGE 4   

 178   1      }
 179          //unsigned int mV = 0;
 180          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
 181          {
 182   1         uint32_t result = 0;
 183   1         // mV = 0;                   // measured voltage in mV
 184   1      
 185   1         ADC0CN0_ADINT = 0;                  // clear ADC0 conv. complete flag
 186   1      
 187   1         result = ADC0;                      // copy ADC0 into result
 188   1      
 189   1         // The 12-bit ADC value represents the voltage applied
 190   1         // to P1.4 according to the following equation:
 191   1         //
 192   1         //                           Vref (mV)
 193   1         //   measurement (mV) =   --------------- * result (bits)
 194   1         //                       ((2^10)-1)*2^2 (bits)
 195   1      
 196   1        // mV =   (uint16_t)(result * 3300 / 4092);
 197   1         //mV = 0;
 198   1        // mV = (unsigned int)result;
 199   1      
 200   1      
 201   1         //clear_adc_busy();
 202   1      }
 203          SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
 204          {
 205   1              TMR2CN0_TF2H = 0;             // clear Timer2 interrupt flag
 206   1              count++;
 207   1              //count_distence++;
 208   1              count_timer++;
 209   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    463    ----
   CONSTANT SIZE    =     61    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
