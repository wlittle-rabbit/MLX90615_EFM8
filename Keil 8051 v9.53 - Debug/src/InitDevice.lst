C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INITDEVICE
OBJECT MODULE PLACED IN .\src\InitDevice.OBJ
COMPILER INVOKED BY: d:\simplicitystdio\developer\toolchains\keil_8051\9.53\BIN\C51.exe E:\elmos1_beetest\src\InitDevice
                    -.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE
                    - INCDIR(E:\elmos1_beetest\inc;D:/simplicitystdio/developer/sdks/si8051/v3//Device/shared/si8051Base;D:/simplicitystdio/d
                    -eveloper/sdks/si8051/v3//Device/EFM8SB1;D:/simplicitystdio/developer/sdks/si8051/v3//Device/EFM8SB1/inc) PRINT(.\src\Ini
                    -tDevice.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\InitDevice.OBJ)

line level    source

   1          //=========================================================
   2          // src/InitDevice.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8SB1_Register_Enums.h>
  11          #include "InitDevice.h"
  12          
  13          #include <compiler_defs.h>
  14          
  15          #include <SI_EFM8SB1_Defs.h>
  16          #include <SmaRTClock.h>
  17          
  18          // USER PROTOTYPES
  19          // USER FUNCTIONS
  20          
  21          
  22          // $[Library Includes]
  23          // [Library Includes]$
  24          #define UART_ENABLE
  25          //==============================================================================
  26          // enter_DefaultMode_from_RESET
  27          //==============================================================================
  28          extern void enter_DefaultMode_from_RESET(void) {
  29   1              // $[Config Calls]
  30   1              // Save the SFRPAGE
  31   1              uint8_t SFRPAGE_save = SFRPAGE;
  32   1              PCA_0_enter_DefaultMode_from_RESET();
  33   1              VREG_0_enter_DefaultMode_from_RESET();
  34   1              PORTS_0_enter_DefaultMode_from_RESET();
  35   1              PORTS_1_enter_DefaultMode_from_RESET();
  36   1              PBCFG_0_enter_DefaultMode_from_RESET();
  37   1              RSTSRC_0_enter_DefaultMode_from_RESET();
  38   1              HFOSC_0_enter_DefaultMode_from_RESET();
  39   1              CLOCK_0_enter_DefaultMode_from_RESET();
  40   1              FLASH_0_enter_DefaultMode_from_RESET();
  41   1              TIMER01_0_enter_DefaultMode_from_RESET();
  42   1              TIMER16_2_enter_DefaultMode_from_RESET();
  43   1              TIMER_SETUP_0_enter_DefaultMode_from_RESET();
  44   1              ADC_0_enter_DefaultMode_from_RESET();
  45   1              UART_0_enter_DefaultMode_from_RESET();
  46   1          //XBR2 = 0x40; // Enable crossbar
  47   1              INTERRUPT_0_enter_DefaultMode_from_RESET();
  48   1              // Restore the SFRPAGE
  49   1              SFRPAGE = SFRPAGE_save;
  50   1              // [Config Calls]$
  51   1      
  52   1      
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 2   

  53   1      }
  54          
  55          
  56          //================================================================================
  57          // PCA_0_enter_DefaultMode_from_RESET
  58          //================================================================================
  59          extern void PCA_0_enter_DefaultMode_from_RESET(void) {
  60   1              // $[PCA0MD - PCA Mode]
  61   1              /*
  62   1              // WDTE (Watchdog Timer Enable) = DISABLED (Disable Watchdog Timer.)
  63   1              // CPS (PCA Counter/Timer Pulse Select) = SYSCLK_DIV_12 (System clock
  64   1              //     divided by 12.)
  65   1              // CIDL (PCA Counter/Timer Idle Control) = NORMAL (PCA continues to
  66   1              //     function normally while the system controller is in Idle Mode.)
  67   1              // ECF (PCA Counter/Timer Overflow Interrupt Enable) = OVF_INT_DISABLED
  68   1              //     (Disable the CF interrupt.)
  69   1              // WDTE (Watchdog Timer Enable) = DISABLED (Disable Watchdog Timer.)
  70   1              // WDLCK (Watchdog Timer Lock) = UNLOCKED (Watchdog Timer Enable
  71   1              //     unlocked.)
  72   1              */
  73   1              SFRPAGE = 0x00;
  74   1              PCA0MD &= ~PCA0MD_WDTE__BMASK;
  75   1              PCA0MD = PCA0MD_CPS__SYSCLK_DIV_12 | PCA0MD_CIDL__NORMAL | PCA0MD_ECF__OVF_INT_DISABLED
  76   1                       | PCA0MD_WDTE__DISABLED | PCA0MD_WDLCK__UNLOCKED;
  77   1              // [PCA0MD - PCA Mode]$
  78   1      
  79   1              // $[PCA0H - PCA Counter/Timer High Byte]
  80   1              // [PCA0H - PCA Counter/Timer High Byte]$
  81   1      
  82   1              // $[PCA0L - PCA Counter/Timer Low Byte]
  83   1              // [PCA0L - PCA Counter/Timer Low Byte]$
  84   1      
  85   1              // $[PCA0PWM - PCA PWM Configuration]
  86   1              // [PCA0PWM - PCA PWM Configuration]$
  87   1      
  88   1              // $[PCA0CN0 - PCA Control 0]
  89   1              // [PCA0CN0 - PCA Control 0]$
  90   1      
  91   1      
  92   1      }
  93          
  94          //================================================================================
  95          // VREG_0_enter_DefaultMode_from_RESET
  96          //================================================================================
  97          extern void VREG_0_enter_DefaultMode_from_RESET(void) {
  98   1              // $[REG0CN - Voltage Regulator Control]
  99   1              /*
 100   1              // OSCBIAS (High Frequency Oscillator Bias) = ENABLED (Enable the
 101   1              //     precision High Frequency Oscillator bias.)
 102   1              */
 103   1              REG0CN = REG0CN_OSCBIAS__ENABLED;
 104   1              // [REG0CN - Voltage Regulator Control]$
 105   1      
 106   1      
 107   1      }
 108          
 109          //================================================================================
 110          // PORTS_0_enter_DefaultMode_from_RESET
 111          //================================================================================
 112          
 113          extern void PORTS_0_enter_DefaultMode_from_RESET(void) {
 114   1              // $[P0 - Port 0 Pin Latch]
 115   1              // [P0 - Port 0 Pin Latch]$
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 3   

 116   1      
 117   1              // $[P0MDOUT - Port 0 Output Mode]
 118   1              // [P0MDOUT - Port 0 Output Mode]$
 119   1      
 120   1              // $[P0MDIN - Port 0 Input Mode]
 121   1              // [P0MDIN - Port 0 Input Mode]$
 122   1      
 123   1              // $[P0SKIP - Port 0 Skip]
 124   1              // [P0SKIP - Port 0 Skip]$
 125   1      
 126   1              // $[P0MASK - Port 0 Mask]
 127   1              /*
 128   1              // B0 (Port 0 Bit 0 Mask Value) = IGNORED (P0.0 pin logic value is
 129   1              //     ignored and will not cause a port mismatch event.)
 130   1              // B1 (Port 0 Bit 1 Mask Value) = IGNORED (P0.1 pin logic value is
 131   1              //     ignored and will not cause a port mismatch event.)
 132   1              // B2 (Port 0 Bit 2 Mask Value) = COMPARED (P0.2 pin logic value is
 133   1              //     compared to P0MAT.2.)
 134   1              // B3 (Port 0 Bit 3 Mask Value) = IGNORED (P0.3 pin logic value is
 135   1              //     ignored and will not cause a port mismatch event.)
 136   1              // B4 (Port 0 Bit 4 Mask Value) = IGNORED (P0.4 pin logic value is
 137   1              //     ignored and will not cause a port mismatch event.)
 138   1              // B5 (Port 0 Bit 5 Mask Value) = IGNORED (P0.5 pin logic value is
 139   1              //     ignored and will not cause a port mismatch event.)
 140   1              // B6 (Port 0 Bit 6 Mask Value) = IGNORED (P0.6 pin logic value is
 141   1              //     ignored and will not cause a port mismatch event.)
 142   1              // B7 (Port 0 Bit 7 Mask Value) = IGNORED (P0.7 pin logic value is
 143   1              //     ignored and will not cause a port mismatch event.)
 144   1              */
 145   1              /*P0MASK = P0MASK_B0__IGNORED | P0MASK_B1__IGNORED | P0MASK_B2__COMPARED
 146   1                       | P0MASK_B3__IGNORED | P0MASK_B4__IGNORED | P0MASK_B5__IGNORED
 147   1                       | P0MASK_B6__IGNORED | P0MASK_B7__IGNORED;*/
 148   1              // [P0MASK - Port 0 Mask]$
 149   1      
 150   1              // $[P0MAT - Port 0 Match]
 151   1              // [P0MAT - Port 0 Match]$
 152   1      
 153   1              // $[P0DRV - Port 0 Drive Strength]
 154   1              // [P0DRV - Port 0 Drive Strength]$
 155   1              //P0MDOUT =  P0MDOUT_B2__OPEN_DRAIN | P0MDOUT_B3__OPEN_DRAIN | P0MDOUT_B4__PUSH_PULL | P0MDOUT_B5__OPEN_D
             -RAIN | P0MDOUT_B6__OPEN_DRAIN;
 156   1              P0MDOUT = P0MDOUT_B0__OPEN_DRAIN| P0MDOUT_B2__OPEN_DRAIN
 157   1                       | P0MDOUT_B3__OPEN_DRAIN | P0MDOUT_B4__OPEN_DRAIN | P0MDOUT_B5__OPEN_DRAIN;
 158   1                      //P0MDIN = (P0MDIN&(~(P0MDIN_B0__BMASK|P0MDIN_B1__BMASK|P0MDIN_B7__BMASK))) | P0MDIN_B0__ANALOG | P0MDIN
             -_B1__DIGITAL | P0MDIN_B7__DIGITAL;
 159   1              P0MDIN = P0MDIN_B0__DIGITAL | P0MDIN_B1__ANALOG | P0MDIN_B2__DIGITAL
 160   1                       | P0MDIN_B3__DIGITAL | P0MDIN_B4__DIGITAL | P0MDIN_B5__DIGITAL
 161   1                       | P0MDIN_B6__DIGITAL | P0MDIN_B7__ANALOG;
 162   1              P0SKIP = P0SKIP_B0__SKIPPED | P0SKIP_B1__NOT_SKIPPED | P0SKIP_B2__NOT_SKIPPED
 163   1                       | P0SKIP_B3__NOT_SKIPPED | P0SKIP_B4__NOT_SKIPPED | P0SKIP_B5__NOT_SKIPPED
 164   1                       | P0SKIP_B6__NOT_SKIPPED | P0SKIP_B7__NOT_SKIPPED;
 165   1              P0MASK = P0MASK_B0__IGNORED | P0MASK_B1__IGNORED | P0MASK_B2__IGNORED
 166   1                       | P0MASK_B3__IGNORED | P0MASK_B4__IGNORED | P0MASK_B5__IGNORED
 167   1                       | P0MASK_B6__COMPARED | P0MASK_B7__IGNORED;
 168   1      
 169   1      }
 170          
 171          //================================================================================
 172          // PORTS_1_enter_DefaultMode_from_RESET
 173          //================================================================================
 174          extern void PORTS_1_enter_DefaultMode_from_RESET(void) {
 175   1              // $[P1 - Port 1 Pin Latch]
 176   1              // [P1 - Port 1 Pin Latch]$
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 4   

 177   1      
 178   1              // $[P1MDOUT - Port 1 Output Mode]
 179   1              /*
 180   1              // B0 (Port 1 Bit 0 Output Mode) = OPEN_DRAIN (P1.0 output is open-
 181   1              //     drain.)
 182   1              // B1 (Port 1 Bit 1 Output Mode) = PUSH_PULL (P1.1 output is push-pull.)
 183   1              // B2 (Port 1 Bit 2 Output Mode) = OPEN_DRAIN (P1.2 output is open-
 184   1              //     drain.)
 185   1              // B3 (Port 1 Bit 3 Output Mode) = OPEN_DRAIN (P1.3 output is open-
 186   1              //     drain.)
 187   1              // B4 (Port 1 Bit 4 Output Mode) = OPEN_DRAIN (P1.4 output is open-
 188   1              //     drain.)
 189   1              // B5 (Port 1 Bit 5 Output Mode) = OPEN_DRAIN (P1.5 output is open-
 190   1              //     drain.)
 191   1              // B6 (Port 1 Bit 6 Output Mode) = OPEN_DRAIN (P1.6 output is open-
 192   1              //     drain.)
 193   1              // B7 (Port 1 Bit 7 Output Mode) = OPEN_DRAIN (P1.7 output is open-
 194   1              //     drain.)
 195   1              */
 196   1              P1MDOUT = P1MDOUT_B0__PUSH_PULL | P1MDOUT_B1__PUSH_PULL | P1MDOUT_B2__PUSH_PULL
 197   1                       | P1MDOUT_B3__OPEN_DRAIN  | P1MDOUT_B5__OPEN_DRAIN
 198   1                       | P1MDOUT_B6__OPEN_DRAIN | P1MDOUT_B7__PUSH_PULL;
 199   1              // [P1MDOUT - Port 1 Output Mode]$
 200   1      
 201   1              // $[P1MDIN - Port 1 Input Mode]
 202   1              /*
 203   1              // B0 (Port 1 Bit 0 Input Mode) = DIGITAL (P1.0 pin is configured for
 204   1              //     digital mode.)
 205   1              // B1 (Port 1 Bit 1 Input Mode) = DIGITAL (P1.1 pin is configured for
 206   1              //     digital mode.)
 207   1              // B2 (Port 1 Bit 2 Input Mode) = DIGITAL (P1.2 pin is configured for
 208   1              //     digital mode.)
 209   1              // B3 (Port 1 Bit 3 Input Mode) = DIGITAL (P1.3 pin is configured for
 210   1              //     digital mode.)
 211   1              // B4 (Port 1 Bit 4 Input Mode) = DIGITAL (P1.4 pin is configured for
 212   1              //     digital mode.)
 213   1              // B5 (Port 1 Bit 5 Input Mode) = DIGITAL (P1.5 pin is configured for
 214   1              //     digital mode.)
 215   1              // B6 (Port 1 Bit 6 Input Mode) = ANALOG (P1.6 pin is configured for
 216   1              //     analog mode.)
 217   1              // B7 (Port 1 Bit 7 Input Mode) = ANALOG (P1.7 pin is configured for
 218   1              //     analog mode.)
 219   1              */
 220   1              P1MDIN =  P1MDIN_B0__DIGITAL | P1MDIN_B1__DIGITAL | P1MDIN_B2__DIGITAL
 221   1                       | P1MDIN_B3__DIGITAL | P1MDIN_B4__ANALOG | P1MDIN_B5__DIGITAL
 222   1                       | P1MDIN_B6__DIGITAL | P1MDIN_B7__DIGITAL;
 223   1              // [P1MDIN - Port 1 Input Mode]$
 224   1      
 225   1              // $[P1SKIP - Port 1 Skip]
 226   1              // [P1SKIP - Port 1 Skip]$
 227   1      
 228   1              // $[P1MASK - Port 1 Mask]
 229   1              /*
 230   1              // B0 (Port 1 Bit 0 Mask Value) = IGNORED (P1.0 pin logic value is
 231   1              //     ignored and will not cause a port mismatch event.)
 232   1              // B1 (Port 1 Bit 1 Mask Value) = IGNORED (P1.1 pin logic value is
 233   1              //     ignored and will not cause a port mismatch event.)
 234   1              // B2 (Port 1 Bit 2 Mask Value) = COMPARED (P1.2 pin logic value is
 235   1              //     compared to P1MAT.2.)
 236   1              // B3 (Port 1 Bit 3 Mask Value) = IGNORED (P1.3 pin logic value is
 237   1              //     ignored and will not cause a port mismatch event.)
 238   1              // B4 (Port 1 Bit 4 Mask Value) = IGNORED (P1.4 pin logic value is
 239   1              //     ignored and will not cause a port mismatch event.)
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 5   

 240   1              // B5 (Port 1 Bit 5 Mask Value) = IGNORED (P1.5 pin logic value is
 241   1              //     ignored and will not cause a port mismatch event.)
 242   1              // B6 (Port 1 Bit 6 Mask Value) = IGNORED (P1.6 pin logic value is
 243   1              //     ignored and will not cause a port mismatch event.)
 244   1              // B7 (Port 1 Bit 7 Mask Value) = IGNORED (P1.7 pin logic value is
 245   1              //     ignored and will not cause a port mismatch event.)
 246   1              */
 247   1                      P1SKIP = P1SKIP_B0__NOT_SKIPPED | P1SKIP_B1__NOT_SKIPPED | P1SKIP_B2__NOT_SKIPPED
 248   1                       | P1SKIP_B3__NOT_SKIPPED | P1SKIP_B4__SKIPPED | P1SKIP_B5__NOT_SKIPPED
 249   1                       | P1SKIP_B6__NOT_SKIPPED | P1SKIP_B7__NOT_SKIPPED;
 250   1              P1MASK = P1MASK_B0__IGNORED | P1MASK_B1__IGNORED | P1MASK_B2__IGNORED
 251   1                       | P1MASK_B3__COMPARED | P1MASK_B4__IGNORED | P1MASK_B5__IGNORED
 252   1                       | P1MASK_B6__IGNORED | P1MASK_B7__IGNORED;
 253   1              // [P1MASK - Port 1 Mask]$
 254   1      
 255   1              // $[P1MAT - Port 1 Match]
 256   1              // [P1MAT - Port 1 Match]$
 257   1      
 258   1              // $[P1DRV - Port 1 Drive Strength]
 259   1              // [P1DRV - Port 1 Drive Strength]$
 260   1      
 261   1      
 262   1      }
 263          
 264          //================================================================================
 265          // PBCFG_0_enter_DefaultMode_from_RESET
 266          //================================================================================
 267          extern void PBCFG_0_enter_DefaultMode_from_RESET(void) {
 268   1              // $[XBR2 - Port I/O Crossbar 2]
 269   1              /*
 270   1              // WEAKPUD (Port I/O Weak Pullup Disable) = PULL_UPS_ENABLED (Weak
 271   1              //     Pullups enabled (except for Ports whose I/O are configured for analog
 272   1              //     mode).)
 273   1              // XBARE (Crossbar Enable) = ENABLED (Crossbar enabled.)
 274   1              */
 275   1              XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED | XBR2_XBARE__ENABLED;
 276   1              // [XBR2 - Port I/O Crossbar 2]$
 277   1      
 278   1              // $[XBR0 - Port I/O Crossbar 0]
 279   1              /*
 280   1              // URT0E (UART I/O Output Enable) = ENABLED (UART TX, RX routed to Port
 281   1              //     pins P0.4 and P0.5.)
 282   1              // SPI0E (SPI I/O Enable) = DISABLED (SPI I/O unavailable at Port pins.)
 283   1              // SMB0E (SMBus0 I/O Enable) = DISABLED (SMBus0 I/O unavailable at Port
 284   1              //     pins.)
 285   1              // CP0E (Comparator0 Output Enable) = DISABLED (CP0 unavailable at Port
 286   1              //     pin.)
 287   1              // CP0AE (Comparator0 Asynchronous Output Enable) = DISABLED
 288   1              //     (Asynchronous CP0 unavailable at Port pin.)
 289   1              // SYSCKE (SYSCLK Output Enable) = DISABLED (SYSCLK unavailable at Port
 290   1              //     pin.)
 291   1              */
 292   1              XBR0 = XBR0_URT0E__ENABLED | XBR0_SPI0E__DISABLED | XBR0_SMB0E__DISABLED
 293   1                       | XBR0_CP0E__DISABLED | XBR0_CP0AE__DISABLED | XBR0_SYSCKE__DISABLED;
 294   1              // [XBR0 - Port I/O Crossbar 0]$
 295   1      
 296   1              // $[XBR1 - Port I/O Crossbar 1]
 297   1              // [XBR1 - Port I/O Crossbar 1]$
 298   1      
 299   1      
 300   1      }
 301          
 302          
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 6   

 303          //================================================================================
 304          // RSTSRC_0_enter_DefaultMode_from_RESET
 305          //================================================================================
 306          extern void RSTSRC_0_enter_DefaultMode_from_RESET(void) {
 307   1              // $[RSTSRC - Reset Source]
 308   1              /*
 309   1              // PORSF (Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset
 310   1              //     Enable) = SET (A power-on or supply monitor reset occurred.)
 311   1              // MCDRSF (Missing Clock Detector Enable and Flag) = SET (A missing clock
 312   1              //     detector reset occurred.)
 313   1              // C0RSEF (Comparator0 Reset Enable and Flag) = NOT_SET (A Comparator 0
 314   1              //     reset did not occur.)
 315   1              // RTC0RE (RTC Reset Enable and Flag) = NOT_SET (A RTC alarm or
 316   1              //     oscillator fail reset did not occur.)
 317   1              */
 318   1      
 319   1      
 320   1              RSTSRC = RSTSRC_PORSF__SET | RSTSRC_MCDRSF__SET | RSTSRC_C0RSEF__NOT_SET
 321   1                       | RSTSRC_RTC0RE__NOT_SET;
 322   1              // [RSTSRC - Reset Source]$
 323   1      
 324   1      
 325   1      }
 326          
 327          //================================================================================
 328          // HFOSC_0_enter_DefaultMode_from_RESET
 329          //================================================================================
 330          extern void HFOSC_0_enter_DefaultMode_from_RESET(void) {
 331   1              // $[HFO#CAL - High Frequency Oscillator Calibration]
 332   1              // [HFO#CAL - High Frequency Oscillator Calibration]$
 333   1      
 334   1              // $[HFO#CN - High Frequency Oscillator Control]
 335   1              /*
 336   1              // IOSCEN (High Frequency Oscillator Enable) = ENABLED (High Frequency
 337   1              //     Oscillator enabled.)
 338   1              */
 339   1              HFO0CN |= HFO0CN_IOSCEN__ENABLED;
 340   1              // [HFO#CN - High Frequency Oscillator Control]$
 341   1      
 342   1              // $[Oscillator Ready]
 343   1              while((HFO0CN & HFO0CN_IFRDY__BMASK) == HFO0CN_IFRDY__NOT_SET);
 344   1              // [Oscillator Ready]$
 345   1      
 346   1      
 347   1      }
 348          
 349          //================================================================================
 350          // CLOCK_0_enter_DefaultMode_from_RESET
 351          //================================================================================
 352          extern void CLOCK_0_enter_DefaultMode_from_RESET(void) {
 353   1              // $[CLKSEL - Clock Select]
 354   1              /*
 355   1              // CLKDIV (Clock Source Divider) = SYSCLK_DIV_1 (SYSCLK is equal to
 356   1              //     selected clock source divided by 1.)
 357   1              // CLKSL (Clock Source Select) = HFOSC (Clock derived from the internal
 358   1              //     precision High-Frequency Oscillator.)
 359   1              */
 360   1              CLKSEL = CLKSEL_CLKDIV__SYSCLK_DIV_1 | CLKSEL_CLKSL__HFOSC;
 361   1              // Wait for the clock to be ready
 362   1              while((CLKSEL & CLKSEL_CLKRDY__BMASK) != CLKSEL_CLKRDY__SET);
 363   1              // [CLKSEL - Clock Select]$
 364   1      
 365   1      
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 7   

 366   1      }
 367          
 368          //================================================================================
 369          // FLASH_0_enter_DefaultMode_from_RESET
 370          //================================================================================
 371          extern void FLASH_0_enter_DefaultMode_from_RESET(void) {
 372   1              // $[FLSCL - Flash Scale]
 373   1              /*
 374   1              // BYPASS (Flash Read Timing One-Shot Bypass) = SYSCLK (The system clock
 375   1              //     determines the flash read time. This setting should be used for
 376   1              //     frequencies greater than 14 MHz.)
 377   1              */
 378   1              //FLSCL = FLSCL_BYPASS__SYSCLK;
 379   1              // [FLSCL - Flash Scale]$
 380   1      
 381   1      
 382   1      }
 383          
 384          //================================================================================
 385          // TIMER01_0_enter_DefaultMode_from_RESET
 386          //================================================================================
 387          
 388          extern void TIMER01_0_enter_DefaultMode_from_RESET(void) {
 389   1              // $[Timer Initialization]
 390   1              //Save Timer Configuration
 391   1              uint8_t TCON_save = TCON;
 392   1              //Stop Timers
 393   1              TCON &= TCON_TR0__BMASK & TCON_TR1__BMASK;
 394   1      
 395   1              // [Timer Initialization]$
 396   1      
 397   1              // $[TH0 - Timer 0 High Byte]
 398   1              // [TH0 - Timer 0 High Byte]$
 399   1      
 400   1              // $[TL0 - Timer 0 Low Byte]
 401   1              // [TL0 - Timer 0 Low Byte]$
 402   1      
 403   1              // $[TH1 - Timer 1 High Byte]
 404   1              /*
 405   1              // TH1 (Timer 1 High Byte) = 0x96
 406   1              */
 407   1              //TH1 = 96;//43;//TH1 = (0x96 << TH1_TH1__SHIFT);
 408   1      
 409   1              TH1 = 43;     //43-57600
 410   1              TL1 = (0xCB << TL1_TL1__SHIFT);
 411   1              TCON = TCON_save;
 412   1              //TMOD &= 0xCF;
 413   1              //TMOD |= 0x20;
 414   1              //TH1 = 149;
 415   1              //TL1 = 170;
 416   1              //TCON = TCON_save;
 417   1              // [Timer Restoration]$
 418   1      
 419   1      
 420   1      }
 421          
 422          //================================================================================
 423          // TIMER16_2_enter_DefaultMode_from_RESET
 424          //================================================================================
 425          extern void TIMER16_2_enter_DefaultMode_from_RESET(void) {
 426   1              // $[Timer Initialization]
 427   1              // Save Timer Configuration
 428   1              uint8_t TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 8   

 429   1              // Stop Timer
 430   1              TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);
 431   1              // [Timer Initialization]$
 432   1      
 433   1              // $[TMR2CN0 - Timer 2 Control]
 434   1              // [TMR2CN0 - Timer 2 Control]$
 435   1      
 436   1              // $[TMR2H - Timer 2 High Byte]
 437   1              /*
 438   1              // TMR2H (Timer 2 High Byte) = 0xB0
 439   1              */
 440   1              TMR2H = (0xB0 << TMR2H_TMR2H__SHIFT);
 441   1              // [TMR2H - Timer 2 High Byte]$
 442   1      
 443   1              // $[TMR2L - Timer 2 Low Byte]
 444   1              /*
 445   1              // TMR2L (Timer 2 Low Byte) = 0x3F
 446   1              */
 447   1              TMR2L = (0x3F << TMR2L_TMR2L__SHIFT);
 448   1              // [TMR2L - Timer 2 Low Byte]$
 449   1      
 450   1              // $[TMR2RLH - Timer 2 Reload High Byte]
 451   1              /*
 452   1              // TMR2RLH (Timer 2 Reload High Byte) = 0xB0
 453   1              */
 454   1              TMR2RLH = (0xB0 << TMR2RLH_TMR2RLH__SHIFT);
 455   1              // [TMR2RLH - Timer 2 Reload High Byte]$
 456   1      
 457   1              // $[TMR2RLL - Timer 2 Reload Low Byte]
 458   1              /*
 459   1              // TMR2RLL (Timer 2 Reload Low Byte) = 0x3F
 460   1              */
 461   1              TMR2RLL = (0x3F << TMR2RLL_TMR2RLL__SHIFT);
 462   1              // [TMR2RLL - Timer 2 Reload Low Byte]$
 463   1      
 464   1              // $[TMR2CN0]
 465   1              /*
 466   1              // TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
 467   1              */
 468   1              TMR2CN0 |= TMR2CN0_TR2__RUN;
 469   1              // [TMR2CN0]$
 470   1      
 471   1              // $[Timer Restoration]
 472   1              // Restore Timer Configuration
 473   1              TMR2CN0 |= TMR2CN0_TR2_save;
 474   1              // [Timer Restoration]$
 475   1      
 476   1      
 477   1      }
 478          
 479          
 480          
 481          extern void TIMER_SETUP_0_enter_DefaultMode_from_RESET(void) {
 482   1              // $[CKCON0 - Clock Control 0]
 483   1              /*
 484   1              // SCA (Timer 0/1 Prescale) = SYSCLK_DIV_12 (System clock divided by 12.)
 485   1              // T0M (Timer 0 Clock Select) = PRESCALE (Counter/Timer 0 uses the clock
 486   1              //     defined by the prescale field, SCA.)
 487   1              // T2MH (Timer 2 High Byte Clock Select) = EXTERNAL_CLOCK (Timer 2 high
 488   1              //     byte uses the clock defined by T2XCLK in TMR2CN0.)
 489   1              // T2ML (Timer 2 Low Byte Clock Select) = EXTERNAL_CLOCK (Timer 2 low
 490   1              //     byte uses the clock defined by T2XCLK in TMR2CN0.)
 491   1              // T3MH (Timer 3 High Byte Clock Select) = EXTERNAL_CLOCK (Timer 3 high
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 9   

 492   1              //     byte uses the clock defined by T3XCLK in TMR3CN0.)
 493   1              // T3ML (Timer 3 Low Byte Clock Select) = EXTERNAL_CLOCK (Timer 3 low
 494   1              //     byte uses the clock defined by T3XCLK in TMR3CN0.)
 495   1              // T1M (Timer 1 Clock Select) = SYSCLK (Timer 1 uses the system clock.)
 496   1              */
 497   1              CKCON0 = CKCON0_SCA__SYSCLK_DIV_12 | CKCON0_T0M__PRESCALE | CKCON0_T2MH__EXTERNAL_CLOCK
 498   1                       | CKCON0_T2ML__EXTERNAL_CLOCK | CKCON0_T3MH__EXTERNAL_CLOCK | CKCON0_T3ML__EXTERNAL_CLOCK
 499   1                       | CKCON0_T1M__SYSCLK;
 500   1              // [CKCON0 - Clock Control 0]$
 501   1      
 502   1              // $[TMOD - Timer 0/1 Mode]
 503   1              /*
 504   1              // T0M (Timer 0 Mode Select) = MODE0 (Mode 0, 13-bit Counter/Timer)
 505   1              // T1M (Timer 1 Mode Select) = MODE2 (Mode 2, 8-bit Counter/Timer with
 506   1              //     Auto-Reload)
 507   1              // CT0 (Counter/Timer 0 Select) = TIMER (Timer Mode. Timer 0 increments
 508   1              //     on the clock defined by T0M in the CKCON register.)
 509   1              // GATE0 (Timer 0 Gate Control) = DISABLED (Timer 0 enabled when TR0 = 1
 510   1              //     irrespective of INT0 logic level.)
 511   1              // CT1 (Counter/Timer 1 Select) = TIMER (Timer Mode. Timer 1 increments
 512   1              //     on the clock defined by T1M in the CKCON register.)
 513   1              // GATE1 (Timer 1 Gate Control) = DISABLED (Timer 1 enabled when TR1 = 1
 514   1              //     irrespective of INT1 logic level.)
 515   1              */
 516   1              TMOD = TMOD_T0M__MODE0 | TMOD_T1M__MODE2 | TMOD_CT0__TIMER | TMOD_GATE0__DISABLED
 517   1                       | TMOD_CT1__TIMER | TMOD_GATE1__DISABLED;
 518   1              // [TMOD - Timer 0/1 Mode]$
 519   1      
 520   1              // $[TCON - Timer 0/1 Control]
 521   1              /*
 522   1              // TR1 (Timer 1 Run Control) = RUN (Start Timer 1 running.)
 523   1              */
 524   1              TCON |= TCON_TR1__RUN;
 525   1              // [TCON - Timer 0/1 Control]$
 526   1      
 527   1      
 528   1      }
 529          
 530          //================================================================================
 531          // ADC_0_enter_DefaultMode_from_RESET
 532          //================================================================================
 533          extern void ADC_0_enter_DefaultMode_from_RESET(void) {
 534   1              // $[ADC0MX - ADC0 Multiplexer Selection]
 535   1              /*
 536   1              // ADC0MX (AMUX0 Positive Input Selection) = ADC0P12 (Select channel
 537   1              //     ADC0.12.)
 538   1              */
 539   1              ADC0MX = ADC0MX_ADC0MX__ADC0P12;
 540   1              // [ADC0MX - ADC0 Multiplexer Selection]$
 541   1      
 542   1              // $[ADC0AC - ADC0 Accumulator Configuration]
 543   1              /*
 544   1              // ADRPT (Repeat Count) = ACC_4 (Perform and Accumulate 4 conversions (1
 545   1              //     conversion in 12-bit mode).)
 546   1              // AD12BE (12-Bit Mode Enable) = 12_BIT_ENABLED (Enable 12-bit mode.)
 547   1              // ADAE (Accumulate Enable) = ACC_DISABLED (ADC0H:ADC0L contain the
 548   1              //     result of the latest conversion when Burst Mode is disabled.)
 549   1              // ADSJST (Accumulator Shift and Justify) = RIGHT_NO_SHIFT (Right
 550   1              //     justified. No shifting applied.)
 551   1              */
 552   1              ADC0AC = ADC0AC_ADRPT__ACC_4 | ADC0AC_AD12BE__12_BIT_ENABLED | ADC0AC_ADAE__ACC_DISABLED
 553   1                       | ADC0AC_ADSJST__RIGHT_NO_SHIFT;
 554   1              // [ADC0AC - ADC0 Accumulator Configuration]$
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 10  

 555   1      
 556   1              // $[ADC0TK - ADC0 Burst Mode Track Time]
 557   1              // [ADC0TK - ADC0 Burst Mode Track Time]$
 558   1      
 559   1              // $[ADC0PWR - ADC0 Power Control]
 560   1              // [ADC0PWR - ADC0 Power Control]$
 561   1      
 562   1              // $[ADC0CF - ADC0 Configuration]
 563   1              /*
 564   1              // AD8BE (8-Bit Mode Enable) = NORMAL (ADC0 operates in 10-bit or 12-bit
 565   1              //     mode (normal operation).)
 566   1              // ADGN (Gain Control) = GAIN_0P5 (The on-chip PGA gain is 0.5.)
 567   1              // ADSC (SAR Clock Divider) = 0x02
 568   1              // ADTM (Track Mode) = TRACK_NORMAL (Normal Track Mode. When ADC0 is
 569   1              //     enabled, conversion begins immediately following the start-of-
 570   1              //     conversion signal.)
 571   1              */
 572   1              ADC0CF = ADC0CF_AD8BE__NORMAL | ADC0CF_ADGN__GAIN_0P5 | (0x02 << ADC0CF_ADSC__SHIFT)
 573   1                       | ADC0CF_ADTM__TRACK_NORMAL;
 574   1              // [ADC0CF - ADC0 Configuration]$
 575   1      
 576   1              // $[ADC0GTH - ADC0 Greater-Than High Byte]
 577   1              /*
 578   1              // ADC0GTH (Greater-Than High Byte) = 0x00
 579   1              */
 580   1              ADC0GTH = (0x00 << ADC0GTH_ADC0GTH__SHIFT);
 581   1              // [ADC0GTH - ADC0 Greater-Than High Byte]$
 582   1      
 583   1              // $[ADC0GTL - ADC0 Greater-Than Low Byte]
 584   1              /*
 585   1              // ADC0GTL (Greater-Than Low Byte) = 0x00
 586   1              */
 587   1              ADC0GTL = (0x00 << ADC0GTL_ADC0GTL__SHIFT);
 588   1              // [ADC0GTL - ADC0 Greater-Than Low Byte]$
 589   1      
 590   1              // $[ADC0LTH - ADC0 Less-Than High Byte]
 591   1              // [ADC0LTH - ADC0 Less-Than High Byte]$
 592   1      
 593   1              // $[ADC0LTL - ADC0 Less-Than Low Byte]
 594   1              // [ADC0LTL - ADC0 Less-Than Low Byte]$
 595   1      
 596   1              // $[ADC0CN0 - ADC0 Control 0]
 597   1              /*
 598   1              // ADBMEN (Burst Mode Enable) = BURST_ENABLED (Enable ADC0 burst mode.)
 599   1              // ADCM (Start of Conversion Mode Select) = TIMER2 (ADC0 conversion
 600   1              //     initiated on overflow of Timer 2.)
 601   1              */
 602   1              ADC0CN0 &= ~ADC0CN0_ADCM__FMASK;
 603   1              ADC0CN0 |= ADC0CN0_ADBMEN__BURST_ENABLED
 604   1                       | ADC0CN0_ADCM__TIMER2;
 605   1              // [ADC0CN0 - ADC0 Control 0]$
 606   1      
 607   1      
 608   1      }
 609          
 610          
 611          //int adc_busy = 0;
 612          
 613          /*extern int enable_adc(int adc) {
 614                  if (adc_busy ||
 615                                  (ADC_CHANNEL_ID != adc && ADC_CHANNEL_VBAT != adc)) {
 616                          return -1;
 617                  }
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 11  

 618                  if (adc == ADC_CHANNEL_ID) {
 619                       ADC0MX = ADC0MX_ADC0MX__ADC0P1;
 620                  } else if (adc == ADC_CHANNEL_VBAT) {
 621                       ADC0MX = ADC0MX_ADC0MX__ADC0P7;
 622                  }
 623                  kick_adc();
 624                  adc_busy = 1;
 625                  return 0;
 626          }*/
 627          
 628          
 629          
 630          
 631          
 632          //================================================================================
 633          // UART_0_enter_DefaultMode_from_RESET
 634          //================================================================================
 635          extern void UART_0_enter_DefaultMode_from_RESET(void) {
 636   1              // $[SCON0 - UART0 Serial Port Control]
 637   1              /*
 638   1              // REN (Receive Enable) = RECEIVE_ENABLED (UART0 reception enabled.)
 639   1              */
 640   1              //SCON0 |= SCON0_REN__RECEIVE_ENABLED;
 641   1              // [SCON0 - UART0 Serial Port Control]$
 642   1      #ifdef UART_ENABLE
 643   1           SCON0 |= SCON0_REN__RECEIVE_ENABLED; // SCON0: 8-bit variable bit rate
 644   1      #endif
 645   1               //        level of STOP bit is ignored
 646   1                   //        RX enabled
 647   1                   //        ninth bits are zeros
 648   1                   //        clear RI0 and TI0 bits
 649   1                   /*
 650   1                   if (SYSCLK / BAUDRATE / 2 / 256 < 1)
 651   1                   {
 652   1                       TH1 = -(SYSCLK / BAUDRATE / 2); // 0x96
 653   1                       CKCON &= ~0x0B; // T1M = 1; SCA1:0 = xx
 654   1                       CKCON |= 0x08;
 655   1                   }
 656   1                   else if (SYSCLK / BAUDRATE / 2 / 256 < 4)
 657   1                   {
 658   1                       TH1 = -(SYSCLK / BAUDRATE / 2 / 4);
 659   1                       CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 01
 660   1                       CKCON |= 0x01;
 661   1                   }
 662   1                   else if (SYSCLK / BAUDRATE / 2 / 256 < 12)
 663   1                   {
 664   1                       TH1 = -(SYSCLK / BAUDRATE / 2 / 12);
 665   1                       CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 00
 666   1                   }
 667   1                   else
 668   1                   {
 669   1                       TH1 = -(SYSCLK / BAUDRATE / 2 / 48);
 670   1                       CKCON &= ~0x0B; // T1M = 0; SCA1:0 = 10
 671   1                       CKCON |= 0x02;
 672   1                   }
 673   1      
 674   1                   TL1 = TH1; // init Timer1
 675   1                   TMOD &= ~0xf0; // TMOD: timer 1 in 8-bit autoreload
 676   1                   TMOD |= 0x20;
 677   1                   TR1 = 1; // START Timer1
 678   1                   */
 679   1      }
 680          
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 12  

 681          extern void UART_0_enter_DefaultMode_to_Normal(void) {
 682   1      
 683   1              // SCON0 &= ~SCON0_REN__RECEIVE_ENABLED; // SCON0: 8-bit variable bit rate
 684   1               XBR0 &= ~XBR0_URT0E__ENABLED;
 685   1      }
 686          
 687          extern void UART_0_enter_DefaultMode_to_Uart(void) {
 688   1      
 689   1      #ifdef UART_ENABLE
 690   1              // SCON0 &= ~SCON0_REN__RECEIVE_ENABLED; // SCON0: 8-bit variable bit rate
 691   1               XBR0 |= XBR0_URT0E__ENABLED;
 692   1      #endif
 693   1      }
 694          
 695          //================================================================================
 696          // INTERRUPT_0_enter_DefaultMode_from_RESET
 697          //================================================================================
 698          extern void INTERRUPT_0_enter_DefaultMode_from_RESET(void) {
 699   1              // $[EIE1 - Extended Interrupt Enable 1]
 700   1              /*
 701   1              // EADC0 (ADC0 Conversion Complete Interrupt Enable) = ENABLED (Enable
 702   1              //     interrupt requests generated by the ADINT flag.)
 703   1              // ECP0 (Comparator0 (CP0) Interrupt Enable) = DISABLED (Disable CP0
 704   1              //     interrupts.)
 705   1              // EPCA0 (Programmable Counter Array (PCA0) Interrupt Enable) = DISABLED
 706   1              //     (Disable all PCA0 interrupts.)
 707   1              // ERTC0A (RTC Alarm Interrupt Enable) = DISABLED (Disable RTC Alarm
 708   1              //     interrupts.)
 709   1              // ESMB0 (SMBus (SMB0) Interrupt Enable) = DISABLED (Disable all SMB0
 710   1              //     interrupts.)
 711   1              // ET3 (Timer 3 Interrupt Enable) = DISABLED (Disable Timer 3
 712   1              //     interrupts.)
 713   1              // EWADC0 (Window Comparison ADC0 Interrupt Enable) = DISABLED (Disable
 714   1              //     ADC0 Window Comparison interrupt.)
 715   1              */
 716   1              EIE1 = EIE1_EADC0__ENABLED | EIE1_ECP0__DISABLED | EIE1_EPCA0__DISABLED
 717   1                       | EIE1_ERTC0A__DISABLED | EIE1_ESMB0__DISABLED | EIE1_ET3__DISABLED
 718   1                       | EIE1_EWADC0__DISABLED;
 719   1              // [EIE1 - Extended Interrupt Enable 1]$
 720   1      
 721   1              // $[EIP1 - Extended Interrupt Priority 1]
 722   1              // [EIP1 - Extended Interrupt Priority 1]$
 723   1      
 724   1              // $[IE - Interrupt Enable]
 725   1              /*
 726   1              // EA (All Interrupts Enable) = ENABLED (Enable each interrupt according
 727   1              //     to its individual mask setting.)
 728   1              // EX0 (External Interrupt 0 Enable) = DISABLED (Disable external
 729   1              //     interrupt 0.)
 730   1              // EX1 (External Interrupt 1 Enable) = DISABLED (Disable external
 731   1              //     interrupt 1.)
 732   1              // ESPI0 (SPI0 Interrupt Enable) = DISABLED (Disable all SPI0
 733   1              //     interrupts.)
 734   1              // ET0 (Timer 0 Interrupt Enable) = DISABLED (Disable all Timer 0
 735   1              //     interrupt.)
 736   1              // ET1 (Timer 1 Interrupt Enable) = DISABLED (Disable all Timer 1
 737   1              //     interrupt.)
 738   1              // ET2 (Timer 2 Interrupt Enable) = DISABLED (Disable Timer 2 interrupt.)
 739   1              // ES0 (UART0 Interrupt Enable) = DISABLED (Disable UART0 interrupt.)
 740   1              */
 741   1              IE = IE_EA__ENABLED | IE_EX0__DISABLED | IE_EX1__DISABLED | IE_ESPI0__DISABLED
 742   1              //       | IE_ET0__DISABLED | IE_ET1__DISABLED | IE_ET2__DISABLED | IE_ES0__DISABLED;
 743   1                              | IE_ET0__DISABLED | IE_ET1__DISABLED | IE_ET2__ENABLED | IE_ES0__DISABLED;
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 13  

 744   1              // [IE - Interrupt Enable]$
 745   1      
 746   1              // $[IP - Interrupt Priority]
 747   1              // [IP - Interrupt Priority]$
 748   1      
 749   1              // $[EIE2 - Extended Interrupt Enable 2]
 750   1              // [EIE2 - Extended Interrupt Enable 2]$
 751   1      
 752   1              // $[EIP2 - Extended Interrupt Priority 2]
 753   1              // [EIP2 - Extended Interrupt Priority 2]$
 754   1      
 755   1      
 756   1      }
 757          
 758          #define TI0 SCON0_TI
 759          #define RI0 SCON0_RI
 760          #define CKCON CKCON0
 761          #define BAUDRATE 115200
 762          
 763          //-----------------------------------------------------------------------------
 764          // Interrupt Service Routines
 765          //-----------------------------------------------------------------------------
 766          
 767          //  uart send, count max number is 255, limited by XRAM size
 768          extern void msleep(int ms);
 769          void uart_send(char *buf, int count)
 770          {
 771   1      #ifdef UART_ENABLE
 772   1              char *ptr = buf;
 773   1              do{
 774   2                  SBUF0 = *ptr++;
 775   2                 // msleep(1000);
 776   2                      while(TI0 == 0);
 777   2                      TI0 = 0;
 778   2              }while(--count);
 779   1      #endif
 780   1      }
 781          
 782          // uart receive, count max 512, limited by XRAM size
 783          void uart_receive(char *buf, int count_uart)
 784          {
 785   1              char* ptr = buf;
 786   1              do{
 787   2                      if(RI0 == 1)
 788   2                      {
 789   3                              *ptr++ = SBUF0;
 790   3                              RI0 = 0;
 791   3                              count_uart--;
 792   3                      }
 793   2              }while(count_uart);
 794   1      }
 795          int uart_receive_timeout(char *buf, int count_uart,int timeout_ms)
 796          {
 797   1              int time=0;
 798   1              char* ptr = buf;
 799   1              do{
 800   2                      if(RI0 == 1)
 801   2                      {
 802   3                              *ptr++ = SBUF0;
 803   3                              RI0 = 0;
 804   3                              count_uart--;
 805   3                      }
 806   2                      if((count_uart)&&(time>=timeout_ms))//timeout
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 14  

 807   2                              return 0;
 808   2                      msleep(1);
 809   2                      time++;
 810   2              }while(count_uart);
 811   1              return 1;
 812   1      }
 813          int uart_receive_have_timeout(long timeout_ms)//受到干扰，读不到正确的串口输入   be disturbed，cannot recv
             - right uart string
 814          {
 815   1              char buf[8]={'1','2','3','4','5','6','7','8'};
 816   1              int count_uart=8;
 817   1              long time=0;
 818   1              char* ptr = buf;
 819   1      
 820   1              while(time<=timeout_ms){
 821   2                      if(RI0!=1)
 822   2                              time++;
 823   2                      else
 824   2                              break;
 825   2              }
 826   1              if(RI0!=1){
 827   2                      return 0;
 828   2              }
 829   1              else{
 830   2                      *ptr++ = SBUF0;
 831   2                      RI0= 0;
 832   2                      count_uart--;
 833   2                      if(buf[0]=='d'){
 834   3                              do{
 835   4                                      if(RI0 == 1)
 836   4                                      {
 837   5                                              *ptr++ = SBUF0;
 838   5                                              RI0 = 0;
 839   5                                              count_uart--;
 840   5                                      }
 841   4                              }while(count_uart);
 842   3                              if((buf[0]=='d')&&(buf[1]=='i')&&(buf[2]=='s')&&(buf[3]=='t')&&(buf[4]=='e')&&(buf[5]=='n')&&(buf[6]=='
             -c')&&(buf[7]=='e')){
 843   4                                      while(RI0==1)//该循环清空这次接受到的所有字节
 844   4                                      {
 845   5                                              buf[0]=SBUF0;
 846   5                                              RI0=0;
 847   5                                      }
 848   4                                      return 1;
 849   4                              }
 850   3                              else{
 851   4                                      uart_send(buf, sizeof(buf));
 852   4                                      while(RI0==1)//该循环清空这次接受到的所有字节
 853   4                                      {
 854   5                                              buf[0]=SBUF0;
 855   5                                              RI0=0;
 856   5                                      }
 857   4                                      return 0;
 858   4                              }
 859   3                      }
 860   2                      else{
 861   3                              while(RI0==1)//该循环清空这次接受到的所有字节
 862   3                              {
 863   4                                      buf[0]=SBUF0;
 864   4                                      RI0=0;
 865   4                              }
 866   3                              return 0;
 867   3                      }
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 15  

 868   2              }
 869   1              /*char buf[8]={'1','2','3','4','5','6','7','8'};
 870   1              int count_uart=8;
 871   1              int time=0;
 872   1              char* ptr = buf;
 873   1              do{
 874   1                      if(RI0 == 1)
 875   1                      {
 876   1                              *ptr++ = SBUF0;
 877   1                              RI0 = 0;
 878   1                              count_uart--;
 879   1                      }
 880   1                      if((count_uart)&&(time>=timeout_ms)){//timeout
 881   1                              uart_send(buf, sizeof(buf));
 882   1                              while(RI0==1)//该循环清空这次接受到的所有字节
 883   1                              {
 884   1                                      buf[0]=SBUF0;
 885   1                                      RI0=0;
 886   1                              }
 887   1                              return 0;
 888   1                      }
 889   1                      if(count_uart==8)
 890   1                              msleep(1);
 891   1                      time++;
 892   1              }while(count_uart);
 893   1              if((buf[0]=='d')&&(buf[1]=='i')&&(buf[2]=='s')&&(buf[3]=='t')&&(buf[4]=='e')&&(buf[5]=='n')&&(buf[6]=='c'
             -)&&(buf[7]=='e')){
 894   1                      return 1;
 895   1              }
 896   1              else{
 897   1                      uart_send(buf, sizeof(buf));
 898   1                      while(RI0==1)//该循环清空这次接受到的所有字节
 899   1                      {
 900   1                              buf[0]=SBUF0;
 901   1                              RI0=0;
 902   1                      }
 903   1                      return 0;
 904   1              }*/
 905   1      /*
 906   1              if(uart_receive_timeout(buf,count_uart,time_ms)){
 907   1                      if((buf[0]=='d')&&(buf[1]=='i')&&(buf[2]=='s')&&(buf[3]=='t')&&(buf[4]=='e')&&(buf[5]=='n')&&(buf[6]=='c
             -')&&(buf[7]=='e')){
 908   1                                      return 1;
 909   1                      }else{
 910   1                              uart_send(buf, sizeof(buf));
 911   1                              while(RI0==1)//该循环清空这次接受到的所有字节
 912   1                              {
 913   1                                      buf[0]=SBUF0;
 914   1                                      RI0=0;
 915   1                              }
 916   1                              return 0;
 917   1                      }
 918   1              }
 919   1              else{
 920   1                      return 0;
 921   1              }
 922   1      */
 923   1      }
 924          int uart_receive_no_timeout()
 925          {
 926   1              char buf[8];
 927   1              char* ptr = buf;
 928   1              int count_uart=8;
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 16  

 929   1              int i=0;
 930   1              do{
 931   2                      if(RI0 == 1)
 932   2                      {
 933   3                              *ptr++ = SBUF0;
 934   3                              RI0 = 0;
 935   3                              count_uart--;
 936   3                      }
 937   2              }while(count_uart);
 938   1              if((buf[0]=='d')&&(buf[1]=='i')&&(buf[2]=='s')&&(buf[3]=='t')&&(buf[4]=='e')&&(buf[5]=='n')&&(buf[6]=='c'
             -)&&(buf[7]=='e')){
 939   2                      return 1;
 940   2              }
 941   1              else{
 942   2                      uart_send(buf, sizeof(buf));
 943   2                      while(RI0==1)//该循环清空这次接受到的所有字节
 944   2                      {
 945   3                              buf[0]=SBUF0;
 946   3                              RI0=0;
 947   3                      }
 948   2                      return 0;
 949   2              }
 950   1      }
 951          /*void uart_receive_phone()
 952          {
 953                  char buf[8];
 954                  char* ptr = buf;
 955                  int count_uart=8;
 956                  do{
 957                          if(RI0 == 1)
 958                          {
 959                                  *ptr++ = SBUF0;
 960                                  RI0 = 0;
 961                                  count_uart--;
 962                          }
 963                  }while(count_uart);
 964                  if((buf[0]=='d')&&(buf[1]=='i')&&(buf[2]=='s')&&(buf[3]=='t')&&(buf[4]=='e')&&(buf[5]=='n')&&(buf[6]=='c'
             -)&&(buf[7]=='e')){
 965                          uart_send("ok", sizeof( "ok"));
 966                          uart_send("\r\n", sizeof( "\r\n"));
 967                  }
 968          }*/
 969          /*int uart_receive_test()
 970          {
 971                  char* ptr;
 972                  int j=0;
 973                  uart_send("f", sizeof( "f"));
 974                  do{
 975                          j++;
 976                          if(RI0 == 1)
 977                          {
 978                                  *ptr++ = SBUF0;
 979                                  RI0 = 0;
 980                                  return 1;
 981                          }
 982                  //}while((count_uart)&&(j<3000));
 983                  }while((j<10000));
 984                  return 0;
 985          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    788    ----
C51 COMPILER V9.53.0.0   INITDEVICE                                                        11/13/2019 15:40:29 PAGE 17  

   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      53
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
